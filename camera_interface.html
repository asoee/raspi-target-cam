<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raspberry Pi Camera Stream</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2em;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .video-container {
            flex: 2;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .video-stream {
            border: 2px solid #34495e;
            border-radius: 8px;
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .controls-panel {
            flex: 1;
            background-color: #ecf0f1;
            padding: 20px;
            border-left: 1px solid #bdc3c7;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .control-row label {
            flex: 1;
            font-weight: bold;
            color: #555;
        }

        .control-row input, .control-row select, .control-row button {
            flex: 1;
            margin-left: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .status {
            margin-top: 20px;
            padding: 10px;
            background-color: #d5f4e6;
            border: 1px solid #27ae60;
            border-radius: 4px;
            color: #27ae60;
            text-align: center;
        }

        .error {
            background-color: #fadbd8;
            border-color: #e74c3c;
            color: #e74c3c;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .controls-panel {
                border-left: none;
                border-top: 1px solid #bdc3c7;
            }
        }

        .debug-stream-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .debug-stream-btn {
            padding: 8px 12px;
            font-size: 12px;
            border: 1px solid #ccc;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .debug-stream-btn:hover:not(:disabled) {
            background: #e9ecef;
        }

        .debug-stream-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Raspberry Pi Target Camera</h1>
            <p>Live camera stream with controls</p>
        </div>

        <div class="main-content">
            <div class="video-container">
                <img id="videoStream"
                     class="video-stream"
                     src="/stream.mjpg"
                     alt="Camera Stream"
                     onerror="handleStreamError()"
                     onload="handleStreamLoad()">

                <div id="streamStatus" class="status">
                    Connecting to camera stream...
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <h3>üîß Camera Controls</h3>

                    <div class="control-row">
                        <label>Video Source:</label>
                        <select id="videoSource" onchange="changeVideoSource()" disabled>
                            <option value="">Loading sources...</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Resolution:</label>
                        <select id="resolution" onchange="changeResolution()" disabled>
                            <option value="640x480">640 x 480 (30fps)</option>
                            <option value="1024x768">1024 x 768 (30fps)</option>
                            <option value="1280x960">1280 x 960 (20fps)</option>
                            <option value="1600x1200">1600 x 1200 (20fps)</option>
                            <option value="2048x1536">2048 x 1536 (20fps)</option>
                            <option value="2592x1944" selected>2592 x 1944 (15fps)</option>
                            <option value="3200x2400">3200 x 2400 (20fps)</option>
                            <option value="3264x2448">3264 x 2448 (15fps)</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Zoom:</label>
                        <input type="range" id="zoom" min="1" max="5" step="0.1" value="1" onchange="adjustZoom()" disabled>
                        <span id="zoomValue">1.0x</span>
                    </div>

                    <div class="control-row">
                        <label>Pan X:</label>
                        <input type="range" id="panX" min="-100" max="100" value="0" onchange="adjustPan()" disabled>
                        <span id="panXValue">0</span>
                    </div>

                    <div class="control-row">
                        <label>Pan Y:</label>
                        <input type="range" id="panY" min="-100" max="100" value="0" onchange="adjustPan()" disabled>
                        <span id="panYValue">0</span>
                    </div>

                    <div class="control-row">
                        <label>Rotation:</label>
                        <select id="rotation" onchange="changeRotation()" disabled>
                            <option value="0">0¬∞ (Normal)</option>
                            <option value="90" selected>90¬∞ (Clockwise)</option>
                            <option value="180">180¬∞ (Upside Down)</option>
                            <option value="270">270¬∞ (Counter-Clockwise)</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Target Detection:</label>
                        <select id="targetDetection" onchange="toggleTargetDetection()" disabled>
                            <option value="true" selected>Enabled</option>
                            <option value="false">Disabled</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Perspective Correction:</label>
                        <select id="perspectiveCorrection" onchange="togglePerspectiveCorrection()" disabled>
                            <option value="false" selected>Disabled</option>
                            <option value="true">Enabled</option>
                        </select>
                    </div>
                </div>

                <div class="control-group" id="playbackControls" style="display: none;">
                    <h3>‚ñ∂Ô∏è Playback Controls</h3>

                    <div class="control-row">
                        <label>Playback Status:</label>
                        <span id="playbackStatus">N/A</span>
                    </div>

                    <div class="control-row">
                        <label>Frame Position:</label>
                        <span id="framePosition">N/A</span>
                    </div>

                    <div class="control-row">
                        <button onclick="pausePlayback()" id="pauseBtn" disabled>
                            ‚è∏Ô∏è Pause
                        </button>
                        <button onclick="resumePlayback()" id="resumeBtn" disabled>
                            ‚ñ∂Ô∏è Resume
                        </button>
                    </div>

                    <div class="control-row">
                        <button onclick="stepBackward()" id="stepBackBtn" disabled>
                            ‚èÆÔ∏è Step Back
                        </button>
                        <button onclick="stepForward()" id="stepForwardBtn" disabled>
                            ‚è≠Ô∏è Step Forward
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üêõ Debug</h3>

                    <div class="control-row">
                        <label>Debug Mode:</label>
                        <select id="debugMode" onchange="toggleDebugMode()" disabled>
                            <option value="false" selected>Disabled</option>
                            <option value="true">Enabled</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Debug View:</label>
                        <select id="debugType" onchange="changeDebugType()" disabled>
                            <option value="combined" selected>Combined</option>
                            <option value="perspective">Perspective Detection</option>
                            <option value="circles">Circle Detection</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Debug Streams:</label>
                        <div class="debug-stream-buttons">
                            <button onclick="openDebugStream('combined')" disabled class="debug-stream-btn">üîÄ Combined</button>
                            <button onclick="openDebugStream('perspective')" disabled class="debug-stream-btn">üìê Perspective</button>
                            <button onclick="openDebugStream('circles')" disabled class="debug-stream-btn">‚≠ï Circles</button>
                            <button onclick="openDebugStream('corrected')" disabled class="debug-stream-btn">üîß Corrected</button>
                        </div>
                    </div>

                    <div class="control-row">
                        <button onclick="forceDetection()" disabled id="forceDetectionBtn">
                            üéØ Force Re-Detection
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üîß Perspective Calibration</h3>

                    <div class="control-row">
                        <label>Calibration Mode:</label>
                        <select id="calibrationMode" onchange="toggleCalibrationMode()" disabled>
                            <option value="false" selected>Normal</option>
                            <option value="true">Calibration</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <button onclick="calibratePerspective()" disabled id="calibrateBtn">
                            üéØ Calibrate Now
                        </button>
                    </div>

                    <div class="control-row">
                        <button onclick="saveCalibration()" disabled id="saveCalibrationBtn">
                            üíæ Save Calibration
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üì∑ Capture</h3>

                    <div class="control-row">
                        <button onclick="captureImage()" disabled id="captureBtn">
                            üì∏ Capture Image
                        </button>
                    </div>

                    <div class="control-row">
                        <button onclick="toggleRecording()" disabled id="recordBtn">
                            üî¥ Start Recording
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>‚ÑπÔ∏è Stream Info</h3>

                    <div class="control-row">
                        <label>Current Resolution:</label>
                        <span id="currentResolution">Loading...</span>
                    </div>

                    <div class="control-row">
                        <label>Current FPS:</label>
                        <span id="currentFPS">Loading...</span>
                    </div>

                    <div class="control-row">
                        <label>Source Type:</label>
                        <span id="sourceType">Loading...</span>
                    </div>

                    <div class="control-row">
                        <label>Stream URL:</label>
                        <input type="text" id="streamUrl" value="/stream.mjpg" readonly>
                    </div>

                    <div class="control-row">
                        <button onclick="refreshStream()">
                            üîÑ Refresh Stream
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let streamConnected = false;
        let recording = false;

        function handleStreamLoad() {
            streamConnected = true;
            updateStatus("‚úÖ Camera stream connected", false);
            enableControls();
        }

        function handleStreamError() {
            streamConnected = false;
            updateStatus("‚ùå Camera stream error - Check if camera_web_stream.py is running", true);
            disableControls();
        }

        function updateStatus(message, isError) {
            const status = document.getElementById('streamStatus');
            status.textContent = message;
            status.className = isError ? 'status error' : 'status';
        }

        function enableControls() {
            const controls = ['videoSource', 'resolution', 'zoom', 'panX', 'panY', 'rotation', 'targetDetection', 'perspectiveCorrection', 'debugMode', 'debugType', 'forceDetectionBtn', 'calibrationMode', 'calibrateBtn', 'saveCalibrationBtn', 'captureBtn', 'recordBtn'];
            controls.forEach(id => {
                document.getElementById(id).disabled = false;
            });

            // Enable debug stream buttons
            const debugButtons = document.querySelectorAll('.debug-stream-btn');
            debugButtons.forEach(btn => btn.disabled = false);
        }

        function disableControls() {
            const controls = ['videoSource', 'resolution', 'zoom', 'panX', 'panY', 'rotation', 'targetDetection', 'perspectiveCorrection', 'debugMode', 'debugType', 'forceDetectionBtn', 'calibrationMode', 'calibrateBtn', 'saveCalibrationBtn', 'captureBtn', 'recordBtn'];
            controls.forEach(id => {
                document.getElementById(id).disabled = true;
            });

            // Disable debug stream buttons
            const debugButtons = document.querySelectorAll('.debug-stream-btn');
            debugButtons.forEach(btn => btn.disabled = true);
        }

        function updateControlsForVideoMode(isVideoMode, nativeResolution, nativeFps) {
            // Controls that should be disabled for video files
            const videoRestrictedControls = ['resolution'];

            // Controls that work differently for video vs camera
            const modifiedControls = ['recordBtn'];

            videoRestrictedControls.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.disabled = isVideoMode;
                    if (isVideoMode) {
                        element.style.opacity = '0.5';
                        element.title = 'Resolution is fixed for video files';
                    } else {
                        element.style.opacity = '';
                        element.title = '';
                    }
                }
            });

            // Update resolution display for video files
            if (isVideoMode && nativeResolution) {
                const resolutionSelect = document.getElementById('resolution');
                const currentValue = `${nativeResolution[0]}x${nativeResolution[1]}`;

                // Find if this resolution exists in the options
                let optionExists = false;
                for (let option of resolutionSelect.options) {
                    if (option.value === currentValue) {
                        optionExists = true;
                        break;
                    }
                }

                // If native resolution doesn't exist in dropdown, add it temporarily
                if (!optionExists) {
                    const option = document.createElement('option');
                    option.value = currentValue;
                    option.textContent = `${nativeResolution[0]} x ${nativeResolution[1]} (Video Native @ ${nativeFps?.toFixed(1) || '?'} fps)`;
                    option.selected = true;
                    resolutionSelect.appendChild(option);
                } else {
                    resolutionSelect.value = currentValue;
                }
            }

            // Update record button for video files
            const recordBtn = document.getElementById('recordBtn');
            if (recordBtn) {
                if (isVideoMode) {
                    recordBtn.textContent = 'üé¨ Playing Video';
                    recordBtn.disabled = true;
                    recordBtn.style.opacity = '0.5';
                    recordBtn.title = 'Cannot record while playing video file';
                } else {
                    recordBtn.textContent = 'üî¥ Start Recording';
                    recordBtn.disabled = false;
                    recordBtn.style.opacity = '';
                    recordBtn.title = '';
                }
            }
        }

        function updateStreamInfo(status) {
            // Update current resolution display
            const currentResolution = document.getElementById('currentResolution');
            if (currentResolution && status.actual_resolution) {
                currentResolution.textContent = `${status.actual_resolution[0]} √ó ${status.actual_resolution[1]}`;

                // Add native info for video files
                if (status.is_video_mode && status.native_video_resolution) {
                    const isNative = (status.actual_resolution[0] === status.native_video_resolution[0] &&
                                    status.actual_resolution[1] === status.native_video_resolution[1]);
                    if (isNative) {
                        currentResolution.textContent += ' (Native)';
                        currentResolution.style.color = '#4CAF50'; // Green for native
                    } else {
                        currentResolution.textContent += ' (Scaled)';
                        currentResolution.style.color = '#FF9800'; // Orange for scaled
                    }
                } else {
                    currentResolution.style.color = ''; // Default color
                }
            }

            // Update current FPS display
            const currentFPS = document.getElementById('currentFPS');
            if (currentFPS && status.actual_fps) {
                const fpsValue = status.actual_fps.toFixed(1);
                currentFPS.textContent = `${fpsValue} fps`;

                // Add native info for video files
                if (status.is_video_mode && status.native_video_fps) {
                    const isNative = Math.abs(status.actual_fps - status.native_video_fps) < 0.1;
                    if (isNative) {
                        currentFPS.textContent += ' (Native)';
                        currentFPS.style.color = '#4CAF50'; // Green for native
                    } else {
                        currentFPS.textContent += ' (Modified)';
                        currentFPS.style.color = '#FF9800'; // Orange for modified
                    }
                } else {
                    currentFPS.style.color = ''; // Default color
                }
            }

            // Update source type display
            const sourceType = document.getElementById('sourceType');
            if (sourceType && status.source_type) {
                if (status.source_type === 'camera') {
                    sourceType.textContent = `üì∑ Camera ${status.current_source}`;
                    sourceType.style.color = '#2196F3'; // Blue for camera
                } else if (status.source_type === 'video') {
                    const filename = status.current_source ? status.current_source.split('/').pop() : 'Unknown';
                    sourceType.textContent = `üé¨ Video: ${filename}`;
                    sourceType.style.color = '#9C27B0'; // Purple for video
                }
            }
        }

        function changeVideoSource() {
            const sourceSelect = document.getElementById('videoSource');
            const selectedValue = sourceSelect.value;

            if (!selectedValue) return;

            const [sourceType, sourceId] = selectedValue.split('|');
            updateStatus(`üîÑ Changing video source to ${sourceId}...`, false);

            apiCall('/api/change_source', { source_type: sourceType, source_id: sourceId })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        setTimeout(() => {
                            refreshStream();
                            loadCameraStatus(); // Reload status to update controls for new source
                        }, 1000);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Source change error: ${error}`, true));
        }

        function changeResolution() {
            const resolution = document.getElementById('resolution').value;
            updateStatus(`üîÑ Changing resolution to ${resolution}...`, false);

            const [width, height] = resolution.split('x').map(Number);
            apiCall('/api/resolution', { width, height })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        setTimeout(refreshStream, 1000);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                        // If resolution change failed (e.g., video mode), reload status to reset UI
                        loadCameraStatus();
                    }
                })
                .catch(error => updateStatus(`‚ùå Error: ${error}`, true));
        }

        function adjustZoom() {
            const zoom = document.getElementById('zoom').value;
            document.getElementById('zoomValue').textContent = zoom + 'x';

            apiCall('/api/zoom', { zoom: parseFloat(zoom) })
                .then(response => {
                    if (!response.success) {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => console.error('Zoom error:', error));
        }

        function adjustPan() {
            const panX = document.getElementById('panX').value;
            const panY = document.getElementById('panY').value;
            document.getElementById('panXValue').textContent = panX;
            document.getElementById('panYValue').textContent = panY;

            apiCall('/api/pan', { pan_x: parseInt(panX), pan_y: parseInt(panY) })
                .then(response => {
                    if (!response.success) {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => console.error('Pan error:', error));
        }

        function changeRotation() {
            const rotation = document.getElementById('rotation').value;
            updateStatus(`üîÑ Changing rotation to ${rotation}¬∞...`, false);

            apiCall('/api/rotation', { rotation: parseInt(rotation) })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Rotation error: ${error}`, true));
        }

        function toggleTargetDetection() {
            const enabled = document.getElementById('targetDetection').value === 'true';
            const status = enabled ? 'Enabling' : 'Disabling';
            updateStatus(`üéØ ${status} target detection...`, false);

            apiCall('/api/target_detection', { enabled: enabled })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Target detection error: ${error}`, true));
        }

        function togglePerspectiveCorrection() {
            const enabled = document.getElementById('perspectiveCorrection').value === 'true';
            const status = enabled ? 'Enabling' : 'Disabling';
            updateStatus(`üîß ${status} perspective correction...`, false);

            apiCall('/api/perspective_correction', { enabled: enabled })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        setTimeout(refreshStream, 1000);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Perspective correction error: ${error}`, true));
        }

        function toggleDebugMode() {
            const enabled = document.getElementById('debugMode').value === 'true';
            const status = enabled ? 'Enabling' : 'Disabling';
            updateStatus(`üêõ ${status} debug mode...`, false);

            apiCall('/api/debug_mode', { enabled: enabled })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Debug mode error: ${error}`, true));
        }

        function openDebugStream(debugType = 'combined') {
            const debugUrl = `/debug.mjpg?type=${debugType}`;
            const windowName = `debugStream_${debugType}`;
            const windowFeatures = 'width=800,height=600,scrollbars=no,resizable=yes';

            window.open(debugUrl, windowName, windowFeatures);
            updateStatus(`üîç ${debugType.charAt(0).toUpperCase() + debugType.slice(1)} debug stream opened in new window`, false);
        }

        function changeDebugType() {
            const debugType = document.getElementById('debugType').value;
            updateStatus(`üîç Changing debug view to ${debugType}...`, false);

            apiCall('/api/debug_type', { debug_type: debugType })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Debug type error: ${error}`, true));
        }

        function forceDetection() {
            updateStatus("üéØ Forcing target re-detection...", false);

            apiCall('/api/force_detection', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Force detection error: ${error}`, true));
        }

        function toggleCalibrationMode() {
            const enabled = document.getElementById('calibrationMode').value === 'true';
            const status = enabled ? 'Enabling' : 'Disabling';
            updateStatus(`üîß ${status} calibration mode...`, false);

            apiCall('/api/calibration_mode', { enabled: enabled })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Calibration mode error: ${error}`, true));
        }

        function calibratePerspective() {
            updateStatus("üéØ Performing perspective calibration...", false);

            apiCall('/api/calibrate_perspective', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Calibration error: ${error}`, true));
        }

        function saveCalibration() {
            updateStatus("üíæ Saving perspective calibration...", false);

            apiCall('/api/save_calibration', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Save calibration error: ${error}`, true));
        }

        function captureImage() {
            updateStatus("üì∏ Capturing image...", false);

            apiCall('/api/capture', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Capture error: ${error}`, true));
        }

        function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            recording = !recording;

            if (recording) {
                btn.textContent = '‚èπÔ∏è Stop Recording';
                updateStatus("üî¥ Recording started...", false);
            } else {
                btn.textContent = 'üî¥ Start Recording';
                updateStatus("‚èπÔ∏è Recording stopped", false);
            }

            // TODO: Implement recording API call
            console.log('Recording toggle requested:', recording);
        }

        function pausePlayback() {
            updateStatus("‚è∏Ô∏è Pausing video playback...", false);

            apiCall('/api/playback_pause', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Pause error: ${error}`, true));
        }

        function resumePlayback() {
            updateStatus("‚ñ∂Ô∏è Resuming video playback...", false);

            apiCall('/api/playback_resume', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Resume error: ${error}`, true));
        }

        function stepForward() {
            updateStatus("‚è≠Ô∏è Stepping forward one frame...", false);

            apiCall('/api/playback_step_forward', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Step forward error: ${error}`, true));
        }

        function stepBackward() {
            updateStatus("‚èÆÔ∏è Stepping backward one frame...", false);

            apiCall('/api/playback_step_backward', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Step backward error: ${error}`, true));
        }

        function updatePlaybackControls() {
            // Fetch current playback info and update UI
            fetch('/api/status')
                .then(response => response.json())
                .then(status => {
                    updatePlaybackUI(status);
                })
                .catch(error => console.error('Failed to update playback controls:', error));
        }

        function updatePlaybackUI(status) {
            const playbackControlsDiv = document.getElementById('playbackControls');
            const playbackStatus = document.getElementById('playbackStatus');
            const framePosition = document.getElementById('framePosition');
            const pauseBtn = document.getElementById('pauseBtn');
            const resumeBtn = document.getElementById('resumeBtn');
            const stepBackBtn = document.getElementById('stepBackBtn');
            const stepForwardBtn = document.getElementById('stepForwardBtn');

            if (status.supports_playback_controls) {
                playbackControlsDiv.style.display = 'block';

                // Update status display
                if (status.paused) {
                    playbackStatus.textContent = '‚è∏Ô∏è Paused';
                    playbackStatus.style.color = '#e67e22'; // Orange
                } else {
                    playbackStatus.textContent = '‚ñ∂Ô∏è Playing';
                    playbackStatus.style.color = '#27ae60'; // Green
                }

                // Update frame position
                if (status.total_frames > 0) {
                    framePosition.textContent = `${status.current_frame} / ${status.total_frames}`;
                } else {
                    framePosition.textContent = 'Unknown';
                }

                // Update button states
                pauseBtn.disabled = status.paused;
                resumeBtn.disabled = !status.paused;
                stepBackBtn.disabled = !status.paused || !status.can_step_backward;
                stepForwardBtn.disabled = !status.paused || !status.can_step_forward;
            } else {
                playbackControlsDiv.style.display = 'none';
            }
        }

        function refreshStream() {
            updateStatus("üîÑ Refreshing stream...", false);
            const img = document.getElementById('videoStream');
            const currentSrc = img.src;
            img.src = '';
            setTimeout(() => {
                img.src = currentSrc + '?t=' + new Date().getTime();
            }, 100);
        }

        // Initialize on page load
        window.addEventListener('load', function() {
            // Load available sources first
            loadAvailableSources();

            // Load current camera status
            loadCameraStatus();

            // Set initial status
            setTimeout(() => {
                if (!streamConnected) {
                    handleStreamError();
                }
            }, 3000);
        });

        // API call helper function
        async function apiCall(endpoint, data) {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            });
            return await response.json();
        }

        // Load available video sources
        function loadAvailableSources() {
            fetch('/api/sources')
                .then(response => response.json())
                .then(sources => {
                    const sourceSelect = document.getElementById('videoSource');
                    sourceSelect.innerHTML = '';

                    // Add cameras
                    if (sources.cameras && sources.cameras.length > 0) {
                        const cameraGroup = document.createElement('optgroup');
                        cameraGroup.label = 'üì∑ Cameras';
                        sources.cameras.forEach(camera => {
                            const option = document.createElement('option');
                            option.value = `camera|${camera.id}`;
                            option.textContent = camera.name;
                            cameraGroup.appendChild(option);
                        });
                        sourceSelect.appendChild(cameraGroup);
                    }

                    // Add video files
                    if (sources.videos && sources.videos.length > 0) {
                        const videoGroup = document.createElement('optgroup');
                        videoGroup.label = 'üé¨ Sample Videos';
                        sources.videos.forEach(video => {
                            const option = document.createElement('option');
                            option.value = `video|${video.id}`;
                            option.textContent = video.name;
                            videoGroup.appendChild(option);
                        });
                        sourceSelect.appendChild(videoGroup);
                    }

                    if (sourceSelect.options.length === 0) {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'No sources available';
                        sourceSelect.appendChild(option);
                    }

                    // Always enable the video source dropdown after loading sources
                    // This allows users to change sources even if current stream fails
                    sourceSelect.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load sources:', error);
                    const sourceSelect = document.getElementById('videoSource');
                    sourceSelect.innerHTML = '<option value="">Error loading sources</option>';
                    // Still enable the dropdown so users can retry
                    sourceSelect.disabled = false;
                });
        }

        // Load camera status on page load
        function loadCameraStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(status => {
                    // Update UI with current camera settings
                    document.getElementById('zoom').value = status.zoom;
                    document.getElementById('zoomValue').textContent = status.zoom + 'x';
                    document.getElementById('panX').value = status.pan_x;
                    document.getElementById('panXValue').textContent = status.pan_x;
                    document.getElementById('panY').value = status.pan_y;
                    document.getElementById('panYValue').textContent = status.pan_y;
                    document.getElementById('rotation').value = status.rotation;
                    document.getElementById('targetDetection').value = status.detection_enabled ? 'true' : 'false';
                    document.getElementById('perspectiveCorrection').value = status.perspective_correction_enabled ? 'true' : 'false';
                    document.getElementById('debugMode').value = status.debug_mode ? 'true' : 'false';
                    document.getElementById('debugType').value = status.debug_type || 'combined';
                    document.getElementById('calibrationMode').value = status.calibration_mode ? 'true' : 'false';

                    const resSelect = document.getElementById('resolution');
                    const currentRes = `${status.resolution[0]}x${status.resolution[1]}`;
                    if ([...resSelect.options].some(opt => opt.value === currentRes)) {
                        resSelect.value = currentRes;
                    }

                    // Set current video source
                    const sourceSelect = document.getElementById('videoSource');
                    let currentSourceValue = '';
                    if (status.source_type === 'camera') {
                        currentSourceValue = `camera|camera_${status.current_source}`;
                    } else if (status.source_type === 'video') {
                        const filename = status.current_source.split('/').pop();
                        currentSourceValue = `video|video_${filename}`;
                    }

                    // Find and select the current source
                    for (let i = 0; i < sourceSelect.options.length; i++) {
                        if (sourceSelect.options[i].value === currentSourceValue) {
                            sourceSelect.selectedIndex = i;
                            break;
                        }
                    }

                    // Update controls based on video mode
                    updateControlsForVideoMode(
                        status.is_video_mode,
                        status.native_video_resolution,
                        status.native_video_fps
                    );

                    // Update stream info display
                    updateStreamInfo(status);

                    // Update playback controls
                    updatePlaybackUI(status);
                })
                .catch(error => console.error('Failed to load status:', error));
        }

        // Auto-refresh stream every 30 seconds to prevent timeout
        setInterval(() => {
            if (streamConnected) {
                console.log('Auto-refreshing stream...');
                const img = document.getElementById('videoStream');
                img.src = img.src.split('?')[0] + '?t=' + new Date().getTime();
            }
        }, 30000);

        // Update playback controls every 2 seconds when video is active
        setInterval(() => {
            if (streamConnected) {
                fetch('/api/status')
                    .then(response => response.json())
                    .then(status => {
                        if (status.supports_playback_controls) {
                            updatePlaybackUI(status);
                        }
                    })
                    .catch(error => console.error('Failed to update playback status:', error));
            }
        }, 2000);
    </script>
</body>
</html>