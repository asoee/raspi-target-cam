<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raspberry Pi Camera Stream</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2em;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        .video-container {
            flex: 2;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .video-stream {
            border: 2px solid #34495e;
            border-radius: 8px;
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .controls-panel {
            flex: 1;
            background-color: #ecf0f1;
            padding: 20px;
            border-left: 1px solid #bdc3c7;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 5px;
        }

        .control-row label {
            flex: 0 0 120px;
            font-weight: bold;
            color: #555;
        }

        .control-row input[type="range"] {
            flex: 1;
            margin: 0 5px;
        }

        .control-row .value-display {
            flex: 0 0 60px;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
        }

        .control-row input, .control-row select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .control-buttons {
            display: flex;
            gap: 3px;
        }

        .control-btn {
            padding: 4px 8px;
            font-size: 12px;
            min-width: 30px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-btn:hover {
            background-color: #2980b9;
        }

        .control-btn.reset {
            background-color: #95a5a6;
        }

        .control-btn.reset:hover {
            background-color: #7f8c8d;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .status {
            margin-top: 20px;
            padding: 10px;
            background-color: #d5f4e6;
            border: 1px solid #27ae60;
            border-radius: 4px;
            color: #27ae60;
            text-align: center;
        }

        .error {
            background-color: #fadbd8;
            border-color: #e74c3c;
            color: #e74c3c;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .controls-panel {
                border-left: none;
                border-top: 1px solid #bdc3c7;
            }
        }

        .debug-stream-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .debug-stream-btn {
            padding: 8px 12px;
            font-size: 12px;
            border: 1px solid #ccc;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .debug-stream-btn:hover:not(:disabled) {
            background: #e9ecef;
        }

        .debug-stream-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Raspberry Pi Target Camera</h1>
            <p>Live camera stream with controls</p>
        </div>

        <div class="main-content">
            <div class="video-container">
                <img id="videoStream"
                     class="video-stream"
                     src="/stream.mjpg"
                     alt="Camera Stream"
                     onerror="handleStreamError()"
                     onload="handleStreamLoad()">

                <div id="streamStatus" class="status">
                    Connecting to camera stream...
                </div>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <h3>üîß Camera Controls</h3>

                    <div class="control-row">
                        <label>Video Source:</label>
                        <select id="videoSource" onchange="changeVideoSource()" disabled>
                            <option value="">Loading sources...</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Resolution & Format:</label>
                        <select id="resolution" onchange="changeResolution()" disabled>
                            <option value="">Loading resolutions...</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Zoom:</label>
                        <input type="range" id="zoom" min="1" max="5" step="0.1" value="1" onchange="adjustZoom()" disabled>
                        <span id="zoomValue">1.0x</span>
                    </div>

                    <div class="control-row">
                        <label>Pan X:</label>
                        <input type="range" id="panX" min="-100" max="100" value="0" onchange="adjustPan()" disabled>
                        <span id="panXValue">0</span>
                    </div>

                    <div class="control-row">
                        <label>Pan Y:</label>
                        <input type="range" id="panY" min="-100" max="100" value="0" onchange="adjustPan()" disabled>
                        <span id="panYValue">0</span>
                    </div>

                    <div class="control-row">
                        <label>Rotation:</label>
                        <select id="rotation" onchange="changeRotation()" disabled>
                            <option value="0">0¬∞ (Normal)</option>
                            <option value="90" selected>90¬∞ (Clockwise)</option>
                            <option value="180">180¬∞ (Upside Down)</option>
                            <option value="270">270¬∞ (Counter-Clockwise)</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <label>Target Detection:</label>
                        <select id="targetDetection" onchange="toggleTargetDetection()" disabled>
                            <option value="true" selected>Enabled</option>
                            <option value="false">Disabled</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Perspective Correction:</label>
                        <select id="perspectiveCorrection" onchange="togglePerspectiveCorrection()" disabled>
                            <option value="true" selected>Enabled</option>
                            <option value="false">Disabled</option>
                        </select>
                    </div>
                </div>

                <div class="control-group" id="cameraControlsGroup">
                    <h3>üìπ Camera Settings</h3>

                    <div id="cameraControlsStatus" class="control-row">
                        <label>Camera Controls:</label>
                        <span id="controlsAvailable">Loading...</span>
                    </div>

                    <!-- Image Quality Controls -->
                    <div id="imageQualityControls" style="display: none;">
                        <h4 style="margin: 15px 0 10px 0; color: #34495e; font-size: 14px;">üé® Image Quality</h4>

                        <div class="control-row">
                            <label>Brightness:</label>
                            <input type="range" id="brightness" min="-64" max="64" value="0" step="1"
                                   onchange="setCameraControl('brightness', this.value)" oninput="updateControlValue('brightness', this.value)">
                            <span class="value-display" id="brightnessValue">0</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('brightness', -1)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('brightness', 1)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('brightness')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Contrast:</label>
                            <input type="range" id="contrast" min="0" max="64" value="32" step="1"
                                   onchange="setCameraControl('contrast', this.value)" oninput="updateControlValue('contrast', this.value)">
                            <span class="value-display" id="contrastValue">32</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('contrast', -1)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('contrast', 1)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('contrast')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Saturation:</label>
                            <input type="range" id="saturation" min="0" max="128" value="75" step="1"
                                   onchange="setCameraControl('saturation', this.value)" oninput="updateControlValue('saturation', this.value)">
                            <span class="value-display" id="saturationValue">75</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('saturation', -1)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('saturation', 1)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('saturation')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Hue:</label>
                            <input type="range" id="hue" min="-40" max="40" value="0" step="1"
                                   onchange="setCameraControl('hue', this.value)" oninput="updateControlValue('hue', this.value)">
                            <span class="value-display" id="hueValue">0</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('hue', -1)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('hue', 1)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('hue')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Sharpness:</label>
                            <input type="range" id="sharpness" min="0" max="6" value="3" step="1"
                                   onchange="setCameraControl('sharpness', this.value)" oninput="updateControlValue('sharpness', this.value)">
                            <span class="value-display" id="sharpnessValue">3</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('sharpness', -1)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('sharpness', 1)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('sharpness')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Gamma:</label>
                            <input type="range" id="gamma" min="72" max="500" value="100" step="1"
                                   onchange="setCameraControl('gamma', this.value)" oninput="updateControlValue('gamma', this.value)">
                            <span class="value-display" id="gammaValue">100</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('gamma', -1)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('gamma', 1)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('gamma')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>
                    </div>

                    <!-- Exposure Controls -->
                    <div id="exposureControls" style="display: none;">
                        <h4 style="margin: 15px 0 10px 0; color: #34495e; font-size: 14px;">‚òÄÔ∏è Exposure</h4>

                        <div class="control-row">
                            <label>Auto Exposure:</label>
                            <select id="auto_exposure" onchange="setCameraControl('auto_exposure', this.value)">
                                <option value="0">Manual</option>
                                <option value="1">Auto</option>
                                <option value="2">Shutter Priority</option>
                                <option value="3" selected>Aperture Priority</option>
                            </select>
                        </div>

                        <div class="control-row">
                            <label>Exposure Time:</label>
                            <input type="range" id="exposure" min="1" max="5000" value="78" step="1"
                                   onchange="setCameraControl('exposure', this.value)" oninput="updateControlValue('exposure', this.value)">
                            <span class="value-display" id="exposureValue">78</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('exposure', -1)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('exposure', 1)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('exposure')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Gain:</label>
                            <input type="range" id="gain" min="0" max="100" value="0" step="1"
                                   onchange="setCameraControl('gain', this.value)" oninput="updateControlValue('gain', this.value)">
                            <span class="value-display" id="gainValue">0</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('gain', -1)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('gain', 1)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('gain')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>Backlight Compensation:</label>
                            <select id="backlight" onchange="setCameraControl('backlight', this.value)">
                                <option value="0">Off</option>
                                <option value="1" selected>Normal</option>
                                <option value="2">Strong</option>
                            </select>
                        </div>
                    </div>

                    <!-- White Balance Controls -->
                    <div id="whiteBalanceControls" style="display: none;">
                        <h4 style="margin: 15px 0 10px 0; color: #34495e; font-size: 14px;">üå°Ô∏è White Balance</h4>

                        <div class="control-row">
                            <label>Auto White Balance:</label>
                            <select id="auto_wb" onchange="setCameraControl('auto_wb', this.value)">
                                <option value="0">Manual</option>
                                <option value="1" selected>Auto</option>
                            </select>
                        </div>

                        <div class="control-row">
                            <label>Color Temperature:</label>
                            <input type="range" id="temperature" min="2800" max="6500" value="4600" step="100"
                                   onchange="setCameraControl('temperature', this.value)" oninput="updateControlValue('temperature', this.value)">
                            <span class="value-display" id="temperatureValue">4600K</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('temperature', -100)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('temperature', 100)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('temperature')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>

                        <div class="control-row">
                            <label>WB Temperature:</label>
                            <input type="range" id="wb_temperature" min="2800" max="6500" value="4600" step="100"
                                   onchange="setCameraControl('wb_temperature', this.value)" oninput="updateControlValue('wb_temperature', this.value)">
                            <span class="value-display" id="wb_temperatureValue">4600K</span>
                            <div class="control-buttons">
                                <button class="control-btn" onclick="adjustControl('wb_temperature', -100)" title="Decrease">‚àí</button>
                                <button class="control-btn" onclick="adjustControl('wb_temperature', 100)" title="Increase">+</button>
                                <button class="control-btn reset" onclick="resetControl('wb_temperature')" title="Reset to default">‚Ü∫</button>
                            </div>
                        </div>
                    </div>

                    <!-- Camera Control Presets -->
                    <div id="presetControls" style="display: none;">
                        <h4 style="margin: 15px 0 10px 0; color: #34495e; font-size: 14px;">üíæ Presets</h4>

                        <div class="control-row">
                            <label>Available Presets:</label>
                            <select id="presetList" onchange="loadSelectedPreset()">
                                <option value="">Select preset...</option>
                            </select>
                            <button onclick="loadSelectedPreset()" disabled id="loadPresetBtn">Load</button>
                        </div>

                        <div class="control-row">
                            <label>Save Preset:</label>
                            <input type="text" id="presetName" placeholder="Enter preset name">
                            <button onclick="saveCurrentPreset()" disabled id="savePresetBtn">Save</button>
                        </div>

                        <div class="control-row">
                            <button onclick="resetCameraControls()" disabled id="resetControlsBtn">
                                üîÑ Reset to Defaults
                            </button>
                        </div>
                    </div>
                </div>

                <div class="control-group" id="playbackControls" style="display: none;">
                    <h3>‚ñ∂Ô∏è Playback Controls</h3>

                    <div class="control-row">
                        <label>Playback Status:</label>
                        <span id="playbackStatus">N/A</span>
                    </div>

                    <div class="control-row">
                        <label>Frame Position:</label>
                        <span id="framePosition">N/A</span>
                    </div>

                    <div class="control-row">
                        <label>Video Position:</label>
                        <input type="range" id="frameSlider" min="0" max="100" value="0" 
                               onchange="seekToFrame()" oninput="updateFramePreview()" disabled>
                    </div>

                    <div class="control-row">
                        <button onclick="pausePlayback()" id="pauseBtn" disabled>
                            ‚è∏Ô∏è Pause
                        </button>
                        <button onclick="resumePlayback()" id="resumeBtn" disabled>
                            ‚ñ∂Ô∏è Resume
                        </button>
                    </div>

                    <div class="control-row">
                        <button onclick="stepBackward()" id="stepBackBtn" disabled>
                            ‚èÆÔ∏è Step Back
                        </button>
                        <button onclick="stepForward()" id="stepForwardBtn" disabled>
                            ‚è≠Ô∏è Step Forward
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üêõ Debug</h3>

                    <div class="control-row">
                        <label>Debug Mode:</label>
                        <select id="debugMode" onchange="toggleDebugMode()" disabled>
                            <option value="false" selected>Disabled</option>
                            <option value="true">Enabled</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Debug View:</label>
                        <select id="debugType" onchange="changeDebugType()" disabled>
                            <option value="combined" selected>Combined</option>
                            <option value="perspective">Perspective Detection</option>
                            <option value="circles">Circle Detection</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>Debug Streams:</label>
                        <div class="debug-stream-buttons">
                            <button onclick="openDebugStream('combined')" disabled class="debug-stream-btn">üîÄ Combined</button>
                            <button onclick="openDebugStream('perspective')" disabled class="debug-stream-btn">üìê Perspective</button>
                            <button onclick="openDebugStream('circles')" disabled class="debug-stream-btn">‚≠ï Circles</button>
                            <button onclick="openDebugStream('corrected')" disabled class="debug-stream-btn">üîß Corrected</button>
                        </div>
                    </div>

                    <div class="control-row">
                        <button onclick="forceDetection()" disabled id="forceDetectionBtn">
                            üéØ Force Re-Detection
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üîß Perspective Calibration</h3>

                    <div class="control-row">
                        <label>Calibration Mode:</label>
                        <select id="calibrationMode" onchange="toggleCalibrationMode()" disabled>
                            <option value="false" selected>Normal</option>
                            <option value="true">Calibration</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <button onclick="calibratePerspective()" disabled id="calibrateBtn">
                            üéØ Calibrate Now
                        </button>
                    </div>

                    <div class="control-row">
                        <button onclick="saveCalibration()" disabled id="saveCalibrationBtn">
                            üíæ Save Calibration
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üì∑ Capture</h3>

                    <div class="control-row">
                        <button onclick="captureImage()" disabled id="captureBtn">
                            üì∏ Capture Image
                        </button>
                    </div>

                    <div class="control-row">
                        <button onclick="toggleRecording()" disabled id="recordBtn">
                            üî¥ Start Recording
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üéØ Bullet Hole Detection</h3>

                    <div class="control-row">
                        <button onclick="setReferenceFrame()" disabled id="setRefBtn">
                            üìã Set Reference Frame
                        </button>
                    </div>

                    <div class="control-row">
                        <button onclick="detectBulletHoles()" disabled id="detectHolesBtn">
                            üîç Detect Bullet Holes
                        </button>
                        <button onclick="clearBulletHoles()" disabled id="clearHolesBtn">
                            üßπ Clear Holes
                        </button>
                    </div>

                    <div class="control-row">
                        <label>Detected Holes:</label>
                        <span id="bulletHoleCount">0</span>
                    </div>
                </div>

                <div class="control-group">
                    <h3>‚ÑπÔ∏è Stream Info</h3>

                    <div class="control-row">
                        <label>Current Resolution:</label>
                        <span id="currentResolution">Loading...</span>
                    </div>

                    <div class="control-row">
                        <label>Current FPS:</label>
                        <span id="currentFPS">Loading...</span>
                    </div>

                    <div class="control-row">
                        <label>Source Type:</label>
                        <span id="sourceType">Loading...</span>
                    </div>

                    <div class="control-row">
                        <label>Stream URL:</label>
                        <input type="text" id="streamUrl" value="/stream.mjpg" readonly>
                    </div>

                    <div class="control-row">
                        <button onclick="refreshStream()">
                            üîÑ Refresh Stream
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let streamConnected = false;
        let recording = false;

        function handleStreamLoad() {
            streamConnected = true;
            updateStatus("‚úÖ Camera stream connected", false);
            enableControls();
        }

        function handleStreamError() {
            streamConnected = false;
            updateStatus("‚ùå Camera stream error - Check if camera_web_stream.py is running", true);
            disableControls();
        }

        function updateStatus(message, isError) {
            const status = document.getElementById('streamStatus');
            status.textContent = message;
            status.className = isError ? 'status error' : 'status';
        }

        function enableControls() {
            const controls = ['videoSource', 'resolution', 'zoom', 'panX', 'panY', 'rotation', 'targetDetection', 'perspectiveCorrection', 'debugMode', 'debugType', 'forceDetectionBtn', 'calibrationMode', 'calibrateBtn', 'saveCalibrationBtn', 'captureBtn', 'recordBtn', 'setRefBtn'];
            controls.forEach(id => {
                document.getElementById(id).disabled = false;
            });

            // Enable debug stream buttons
            const debugButtons = document.querySelectorAll('.debug-stream-btn');
            debugButtons.forEach(btn => btn.disabled = false);
            
            // Note: detectHolesBtn is enabled only after setting reference frame
        }

        function disableControls() {
            const controls = ['videoSource', 'resolution', 'zoom', 'panX', 'panY', 'rotation', 'targetDetection', 'perspectiveCorrection', 'debugMode', 'debugType', 'forceDetectionBtn', 'calibrationMode', 'calibrateBtn', 'saveCalibrationBtn', 'captureBtn', 'recordBtn'];
            controls.forEach(id => {
                document.getElementById(id).disabled = true;
            });

            // Disable debug stream buttons
            const debugButtons = document.querySelectorAll('.debug-stream-btn');
            debugButtons.forEach(btn => btn.disabled = true);
        }

        function updateControlsForVideoMode(isVideoMode, nativeResolution, nativeFps) {
            // Controls that should be disabled for video files
            const videoRestrictedControls = ['resolution'];

            // Controls that work differently for video vs camera
            const modifiedControls = ['recordBtn'];

            videoRestrictedControls.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.disabled = isVideoMode;
                    if (isVideoMode) {
                        element.style.opacity = '0.5';
                        element.title = 'Resolution is fixed for video files';
                    } else {
                        element.style.opacity = '';
                        element.title = '';
                    }
                }
            });

            // Update resolution display for video files
            if (isVideoMode && nativeResolution) {
                const resolutionSelect = document.getElementById('resolution');
                const currentValue = `${nativeResolution[0]}x${nativeResolution[1]}`;

                // Find if this resolution exists in the options
                let optionExists = false;
                for (let option of resolutionSelect.options) {
                    if (option.value === currentValue) {
                        optionExists = true;
                        break;
                    }
                }

                // If native resolution doesn't exist in dropdown, add it temporarily
                if (!optionExists) {
                    const option = document.createElement('option');
                    option.value = currentValue;
                    option.textContent = `${nativeResolution[0]} x ${nativeResolution[1]} (Video Native @ ${nativeFps?.toFixed(1) || '?'} fps)`;
                    option.selected = true;
                    resolutionSelect.appendChild(option);
                } else {
                    resolutionSelect.value = currentValue;
                }
            }

            // Update record button for video files
            const recordBtn = document.getElementById('recordBtn');
            if (recordBtn) {
                if (isVideoMode) {
                    recordBtn.textContent = 'üé¨ Playing Video';
                    recordBtn.disabled = true;
                    recordBtn.style.opacity = '0.5';
                    recordBtn.title = 'Cannot record while playing video file';
                } else {
                    recordBtn.textContent = 'üî¥ Start Recording';
                    recordBtn.disabled = false;
                    recordBtn.style.opacity = '';
                    recordBtn.title = '';
                }
            }
        }

        function updateStreamInfo(status) {
            // Update current resolution display
            const currentResolution = document.getElementById('currentResolution');
            if (currentResolution && status.actual_resolution) {
                currentResolution.textContent = `${status.actual_resolution[0]} √ó ${status.actual_resolution[1]}`;

                // Add native info for video files
                if (status.is_video_mode && status.native_video_resolution) {
                    const isNative = (status.actual_resolution[0] === status.native_video_resolution[0] &&
                                    status.actual_resolution[1] === status.native_video_resolution[1]);
                    if (isNative) {
                        currentResolution.textContent += ' (Native)';
                        currentResolution.style.color = '#4CAF50'; // Green for native
                    } else {
                        currentResolution.textContent += ' (Scaled)';
                        currentResolution.style.color = '#FF9800'; // Orange for scaled
                    }
                } else {
                    currentResolution.style.color = ''; // Default color
                }
            }

            // Update current FPS display
            const currentFPS = document.getElementById('currentFPS');
            if (currentFPS && status.actual_fps) {
                const fpsValue = status.actual_fps.toFixed(1);
                currentFPS.textContent = `${fpsValue} fps`;

                // Add native info for video files
                if (status.is_video_mode && status.native_video_fps) {
                    const isNative = Math.abs(status.actual_fps - status.native_video_fps) < 0.1;
                    if (isNative) {
                        currentFPS.textContent += ' (Native)';
                        currentFPS.style.color = '#4CAF50'; // Green for native
                    } else {
                        currentFPS.textContent += ' (Modified)';
                        currentFPS.style.color = '#FF9800'; // Orange for modified
                    }
                } else {
                    currentFPS.style.color = ''; // Default color
                }
            }

            // Update source type display
            const sourceType = document.getElementById('sourceType');
            if (sourceType && status.source_type) {
                if (status.source_type === 'camera') {
                    sourceType.textContent = `üì∑ Camera ${status.current_source}`;
                    sourceType.style.color = '#2196F3'; // Blue for camera
                } else if (status.source_type === 'video') {
                    const filename = status.current_source ? status.current_source.split('/').pop() : 'Unknown';
                    sourceType.textContent = `üé¨ Video: ${filename}`;
                    sourceType.style.color = '#9C27B0'; // Purple for video
                }
            }
        }

        function changeVideoSource() {
            const sourceSelect = document.getElementById('videoSource');
            const selectedValue = sourceSelect.value;

            if (!selectedValue) return;

            const [sourceType, sourceId] = selectedValue.split('|');
            updateStatus(`üîÑ Changing video source to ${sourceId}...`, false);

            apiCall('/api/change_source', { source_type: sourceType, source_id: sourceId })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        setTimeout(() => {
                            refreshStream();
                            loadCameraStatus(); // Reload status to update controls for new source
                        }, 1000);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Source change error: ${error}`, true));
        }

        function changeResolution() {
            const resolutionValue = document.getElementById('resolution').value;

            if (!resolutionValue) return;

            // Parse the new format: "640x480@30fps_MJPG"
            const parts = resolutionValue.split('@');
            if (parts.length < 2) {
                updateStatus('‚ùå Invalid resolution format', true);
                return;
            }

            const resolution = parts[0]; // "640x480"
            const fpsAndFormat = parts[1]; // "30fps_MJPG"
            const [fpsStr, format] = fpsAndFormat.split('_');
            const fps = parseFloat(fpsStr.replace('fps', ''));

            updateStatus(`üîÑ Changing to ${resolution} @ ${fps}fps (${format})...`, false);

            const [width, height] = resolution.split('x').map(Number);

            // Send resolution change with format information
            apiCall('/api/resolution', {
                width,
                height,
                fps: fps,
                format: format
            })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        setTimeout(refreshStream, 1000);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                        // If resolution change failed (e.g., video mode), reload status to reset UI
                        loadCameraStatus();
                    }
                })
                .catch(error => updateStatus(`‚ùå Error: ${error}`, true));
        }

        function adjustZoom() {
            const zoom = document.getElementById('zoom').value;
            document.getElementById('zoomValue').textContent = zoom + 'x';

            apiCall('/api/zoom', { zoom: parseFloat(zoom) })
                .then(response => {
                    if (!response.success) {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => console.error('Zoom error:', error));
        }

        function adjustPan() {
            const panX = document.getElementById('panX').value;
            const panY = document.getElementById('panY').value;
            document.getElementById('panXValue').textContent = panX;
            document.getElementById('panYValue').textContent = panY;

            apiCall('/api/pan', { pan_x: parseInt(panX), pan_y: parseInt(panY) })
                .then(response => {
                    if (!response.success) {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => console.error('Pan error:', error));
        }

        function changeRotation() {
            const rotation = document.getElementById('rotation').value;
            updateStatus(`üîÑ Changing rotation to ${rotation}¬∞...`, false);

            apiCall('/api/rotation', { rotation: parseInt(rotation) })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Rotation error: ${error}`, true));
        }

        function toggleTargetDetection() {
            const enabled = document.getElementById('targetDetection').value === 'true';
            const status = enabled ? 'Enabling' : 'Disabling';
            updateStatus(`üéØ ${status} target detection...`, false);

            apiCall('/api/target_detection', { enabled: enabled })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Target detection error: ${error}`, true));
        }

        function togglePerspectiveCorrection() {
            const enabled = document.getElementById('perspectiveCorrection').value === 'true';
            const status = enabled ? 'Enabling' : 'Disabling';
            updateStatus(`üîß ${status} perspective correction...`, false);

            apiCall('/api/perspective_correction', { enabled: enabled })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        setTimeout(refreshStream, 1000);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Perspective correction error: ${error}`, true));
        }

        function toggleDebugMode() {
            const enabled = document.getElementById('debugMode').value === 'true';
            const status = enabled ? 'Enabling' : 'Disabling';
            updateStatus(`üêõ ${status} debug mode...`, false);

            apiCall('/api/debug_mode', { enabled: enabled })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Debug mode error: ${error}`, true));
        }

        function openDebugStream(debugType = 'combined') {
            const debugUrl = `/debug.mjpg?type=${debugType}`;
            const windowName = `debugStream_${debugType}`;
            const windowFeatures = 'width=800,height=600,scrollbars=no,resizable=yes';

            window.open(debugUrl, windowName, windowFeatures);
            updateStatus(`üîç ${debugType.charAt(0).toUpperCase() + debugType.slice(1)} debug stream opened in new window`, false);
        }

        function changeDebugType() {
            const debugType = document.getElementById('debugType').value;
            updateStatus(`üîç Changing debug view to ${debugType}...`, false);

            apiCall('/api/debug_type', { debug_type: debugType })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Debug type error: ${error}`, true));
        }

        function forceDetection() {
            updateStatus("üéØ Forcing target re-detection...", false);

            apiCall('/api/force_detection', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Force detection error: ${error}`, true));
        }

        function toggleCalibrationMode() {
            const enabled = document.getElementById('calibrationMode').value === 'true';
            const status = enabled ? 'Enabling' : 'Disabling';
            updateStatus(`üîß ${status} calibration mode...`, false);

            apiCall('/api/calibration_mode', { enabled: enabled })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Calibration mode error: ${error}`, true));
        }

        function calibratePerspective() {
            updateStatus("üéØ Performing perspective calibration...", false);

            apiCall('/api/calibrate_perspective', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Calibration error: ${error}`, true));
        }

        function saveCalibration() {
            updateStatus("üíæ Saving perspective calibration...", false);

            apiCall('/api/save_calibration', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Save calibration error: ${error}`, true));
        }

        function captureImage() {
            updateStatus("üì∏ Capturing image...", false);

            apiCall('/api/capture', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Capture error: ${error}`, true));
        }

        function toggleRecording() {
            const btn = document.getElementById('recordBtn');

            if (recording) {
                // Stop recording
                updateStatus("‚èπÔ∏è Stopping recording...", false);
                btn.disabled = true;

                apiCall('/api/stop_recording', {})
                    .then(response => {
                        if (response.success) {
                            recording = false;
                            btn.textContent = 'üî¥ Start Recording';
                            btn.disabled = false;
                            updateStatus(`‚úÖ ${response.message}`, false);
                        } else {
                            btn.disabled = false;
                            updateStatus(`‚ùå ${response.message}`, true);
                        }
                    })
                    .catch(error => {
                        btn.disabled = false;
                        updateStatus(`‚ùå Stop recording error: ${error}`, true);
                    });
            } else {
                // Start recording
                updateStatus("üî¥ Starting recording...", false);
                btn.disabled = true;

                apiCall('/api/start_recording', {})
                    .then(response => {
                        if (response.success) {
                            recording = true;
                            btn.textContent = '‚èπÔ∏è Stop Recording';
                            btn.disabled = false;
                            updateStatus(`‚úÖ ${response.message}`, false);
                        } else {
                            btn.disabled = false;
                            updateStatus(`‚ùå ${response.message}`, true);
                        }
                    })
                    .catch(error => {
                        btn.disabled = false;
                        updateStatus(`‚ùå Start recording error: ${error}`, true);
                    });
            }
        }

        function setReferenceFrame() {
            updateStatus("üìã Setting reference frame for bullet hole detection...", false);

            apiCall('/api/set_reference_frame', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        // Enable the detect button after setting reference
                        document.getElementById('detectHolesBtn').disabled = false;
                        document.getElementById('clearHolesBtn').disabled = false;
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Set reference error: ${error}`, true));
        }

        function detectBulletHoles() {
            updateStatus("üîç Detecting bullet holes...", false);

            apiCall('/api/detect_bullet_holes', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        
                        // Update bullet hole count
                        const holeCount = response.bullet_holes ? response.bullet_holes.length : 0;
                        document.getElementById('bulletHoleCount').textContent = holeCount;
                        
                        // Display bullet hole details
                        if (response.bullet_holes && response.bullet_holes.length > 0) {
                            let details = "\\nDetected holes:\\n";
                            response.bullet_holes.forEach((hole, i) => {
                                details += `Hole ${i+1}: (${hole.x}, ${hole.y}) radius=${hole.radius}px score=${hole.score.toFixed(3)}\\n`;
                            });
                            updateStatus(`üéØ ${response.message}${details}`, false);
                        }
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Detection error: ${error}`, true));
        }

        function clearBulletHoles() {
            updateStatus("üßπ Clearing bullet holes...", false);

            apiCall('/api/clear_bullet_holes', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        
                        // Reset bullet hole count
                        document.getElementById('bulletHoleCount').textContent = '0';
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Clear holes error: ${error}`, true));
        }

        function pausePlayback() {
            updateStatus("‚è∏Ô∏è Pausing video playback...", false);

            apiCall('/api/playback_pause', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Pause error: ${error}`, true));
        }

        function resumePlayback() {
            updateStatus("‚ñ∂Ô∏è Resuming video playback...", false);

            apiCall('/api/playback_resume', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Resume error: ${error}`, true));
        }

        function stepForward() {
            updateStatus("‚è≠Ô∏è Stepping forward one frame...", false);

            apiCall('/api/playback_step_forward', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Step forward error: ${error}`, true));
        }

        function stepBackward() {
            updateStatus("‚èÆÔ∏è Stepping backward one frame...", false);

            apiCall('/api/playback_step_backward', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Step backward error: ${error}`, true));
        }

        function seekToFrame() {
            const slider = document.getElementById('frameSlider');
            const targetFrame = parseInt(slider.value);
            
            updateStatus(`‚è≠Ô∏è Seeking to frame ${targetFrame}...`, false);

            apiCall('/api/seek_to_frame', { frame: targetFrame })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        updatePlaybackControls();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Seek error: ${error}`, true));
        }

        function updateFramePreview() {
            const slider = document.getElementById('frameSlider');
            const framePosition = document.getElementById('framePosition');
            
            // Get total frames from the slider's max value
            const totalFrames = parseInt(slider.max);
            const currentFrame = parseInt(slider.value);
            
            // Update the frame position display in real-time as user drags
            if (totalFrames > 0) {
                framePosition.textContent = `${currentFrame} / ${totalFrames}`;
            }
        }

        function updatePlaybackControls() {
            // Fetch current playback info and update UI
            fetch('/api/status')
                .then(response => response.json())
                .then(status => {
                    updatePlaybackUI(status);
                })
                .catch(error => console.error('Failed to update playback controls:', error));
        }

        function updatePlaybackUI(status) {
            const playbackControlsDiv = document.getElementById('playbackControls');
            const playbackStatus = document.getElementById('playbackStatus');
            const framePosition = document.getElementById('framePosition');
            const frameSlider = document.getElementById('frameSlider');
            const pauseBtn = document.getElementById('pauseBtn');
            const resumeBtn = document.getElementById('resumeBtn');
            const stepBackBtn = document.getElementById('stepBackBtn');
            const stepForwardBtn = document.getElementById('stepForwardBtn');

            if (status.supports_playback_controls) {
                playbackControlsDiv.style.display = 'block';

                // Update status display
                if (status.paused) {
                    playbackStatus.textContent = '‚è∏Ô∏è Paused';
                    playbackStatus.style.color = '#e67e22'; // Orange
                } else {
                    playbackStatus.textContent = '‚ñ∂Ô∏è Playing';
                    playbackStatus.style.color = '#27ae60'; // Green
                }

                // Update frame position and slider
                if (status.total_frames > 0) {
                    framePosition.textContent = `${status.current_frame} / ${status.total_frames}`;
                    
                    // Update slider range and position
                    frameSlider.max = status.total_frames;
                    frameSlider.value = status.current_frame;
                    frameSlider.disabled = false;
                } else {
                    framePosition.textContent = 'Unknown';
                    frameSlider.disabled = true;
                }

                // Update button states
                pauseBtn.disabled = status.paused;
                resumeBtn.disabled = !status.paused;
                stepBackBtn.disabled = !status.paused || !status.can_step_backward;
                stepForwardBtn.disabled = !status.paused || !status.can_step_forward;
            } else {
                playbackControlsDiv.style.display = 'none';
            }
        }

        function refreshStream() {
            updateStatus("üîÑ Refreshing stream...", false);
            const img = document.getElementById('videoStream');
            const currentSrc = img.src;
            img.src = '';
            setTimeout(() => {
                img.src = currentSrc + '?t=' + new Date().getTime();
            }, 100);
        }

        // Camera Controls Functions
        function updateControlValue(controlName, value) {
            // Update the display value immediately
            const valueElement = document.getElementById(controlName + 'Value');
            if (valueElement) {
                if (controlName === 'temperature' || controlName === 'wb_temperature') {
                    valueElement.textContent = value + 'K';
                } else {
                    valueElement.textContent = value;
                }
            }
        }

        function setCameraControl(controlName, value) {
            updateStatus(`üéõÔ∏è Setting ${controlName} to ${value}...`, false);

            apiCall('/api/set_camera_control', { name: controlName, value: parseFloat(value) })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        // Update the displayed value
                        updateControlValue(controlName, value);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                        // Revert the UI control to its previous value
                        loadCameraControls();
                    }
                })
                .catch(error => {
                    updateStatus(`‚ùå Control error: ${error}`, true);
                    // Revert the UI control to its previous value
                    loadCameraControls();
                });
        }

        function adjustControl(controlName, delta) {
            const element = document.getElementById(controlName);
            if (!element) return;

            const currentValue = parseFloat(element.value);
            const step = parseFloat(element.step) || 1;
            const min = parseFloat(element.min);
            const max = parseFloat(element.max);

            // Calculate new value
            let newValue = currentValue + delta;

            // Clamp to valid range
            newValue = Math.max(min, Math.min(max, newValue));

            // Update slider and trigger change
            element.value = newValue;
            updateControlValue(controlName, newValue);
            setCameraControl(controlName, newValue);
        }

        function resetControl(controlName) {
            // Fetch current control info to get default value
            fetch('/api/camera_controls')
                .then(response => response.json())
                .then(result => {
                    if (result.success && result.data.available) {
                        const control = result.data.controls[controlName];
                        if (control && control.default !== null && control.default !== undefined) {
                            const element = document.getElementById(controlName);
                            if (element) {
                                element.value = control.default;
                                updateControlValue(controlName, control.default);
                                setCameraControl(controlName, control.default);
                                updateStatus(`üîÑ Reset ${controlName} to default (${control.default})`, false);
                            }
                        } else {
                            updateStatus(`‚ö†Ô∏è No default value available for ${controlName}`, true);
                        }
                    }
                })
                .catch(error => {
                    updateStatus(`‚ùå Error resetting control: ${error}`, true);
                });
        }

        function loadCameraControls() {
            fetch('/api/camera_controls')
                .then(response => response.json())
                .then(result => {
                    const controlsAvailable = document.getElementById('controlsAvailable');
                    const imageQualityControls = document.getElementById('imageQualityControls');
                    const exposureControls = document.getElementById('exposureControls');
                    const whiteBalanceControls = document.getElementById('whiteBalanceControls');
                    const presetControls = document.getElementById('presetControls');

                    if (result.success && result.data.available) {
                        const controls = result.data.controls;
                        controlsAvailable.textContent = `‚úÖ ${Object.keys(controls).length} controls available`;
                        controlsAvailable.style.color = '#27ae60';

                        // Show control sections
                        imageQualityControls.style.display = 'block';
                        exposureControls.style.display = 'block';
                        whiteBalanceControls.style.display = 'block';
                        presetControls.style.display = 'block';

                        // Update control values and ranges
                        Object.keys(controls).forEach(controlName => {
                            const control = controls[controlName];
                            const element = document.getElementById(controlName);

                            if (element) {
                                // Update current value
                                element.value = control.current;

                                // Update range if available
                                if (control.min !== null && control.min !== undefined) {
                                    element.min = control.min;
                                }
                                if (control.max !== null && control.max !== undefined) {
                                    element.max = control.max;
                                }

                                // Update display value
                                updateControlValue(controlName, control.current);

                                // Enable the control
                                element.disabled = false;
                            }
                        });

                        // Enable preset buttons
                        document.getElementById('savePresetBtn').disabled = false;
                        document.getElementById('resetControlsBtn').disabled = false;

                        // Load available presets
                        loadPresetList();

                    } else {
                        controlsAvailable.textContent = '‚ùå Camera controls not available';
                        controlsAvailable.style.color = '#e74c3c';

                        // Hide control sections
                        imageQualityControls.style.display = 'none';
                        exposureControls.style.display = 'none';
                        whiteBalanceControls.style.display = 'none';
                        presetControls.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Failed to load camera controls:', error);
                    const controlsAvailable = document.getElementById('controlsAvailable');
                    controlsAvailable.textContent = '‚ùå Error loading controls';
                    controlsAvailable.style.color = '#e74c3c';
                });
        }

        function loadPresetList() {
            fetch('/api/list_camera_presets')
                .then(response => response.json())
                .then(result => {
                    const presetList = document.getElementById('presetList');
                    const loadPresetBtn = document.getElementById('loadPresetBtn');

                    // Clear existing options except the first one
                    while (presetList.options.length > 1) {
                        presetList.removeChild(presetList.lastChild);
                    }

                    if (result.success && result.presets.length > 0) {
                        result.presets.forEach(presetName => {
                            const option = document.createElement('option');
                            option.value = presetName;
                            option.textContent = presetName;
                            presetList.appendChild(option);
                        });

                        loadPresetBtn.disabled = false;
                    } else {
                        loadPresetBtn.disabled = true;
                    }
                })
                .catch(error => {
                    console.error('Failed to load presets:', error);
                });
        }

        function loadSelectedPreset() {
            const presetList = document.getElementById('presetList');
            const selectedPreset = presetList.value;

            if (!selectedPreset) return;

            updateStatus(`üíæ Loading preset '${selectedPreset}'...`, false);

            apiCall('/api/load_camera_preset', { name: selectedPreset })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        // Reload camera controls to update UI
                        setTimeout(() => loadCameraControls(), 500);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Load preset error: ${error}`, true));
        }

        function saveCurrentPreset() {
            const presetNameInput = document.getElementById('presetName');
            const presetName = presetNameInput.value.trim();

            if (!presetName) {
                updateStatus('‚ùå Please enter a preset name', true);
                return;
            }

            updateStatus(`üíæ Saving preset '${presetName}'...`, false);

            apiCall('/api/save_camera_preset', { name: presetName })
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        presetNameInput.value = '';
                        // Reload preset list
                        loadPresetList();
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Save preset error: ${error}`, true));
        }

        function resetCameraControls() {
            if (!confirm('Reset all camera controls to their default values?')) {
                return;
            }

            updateStatus('üîÑ Resetting camera controls to defaults...', false);

            apiCall('/api/reset_camera_controls', {})
                .then(response => {
                    if (response.success) {
                        updateStatus(`‚úÖ ${response.message}`, false);
                        // Reload camera controls to update UI
                        setTimeout(() => loadCameraControls(), 500);
                    } else {
                        updateStatus(`‚ùå ${response.message}`, true);
                    }
                })
                .catch(error => updateStatus(`‚ùå Reset error: ${error}`, true));
        }

        // Load camera format and resolution options
        function loadCameraFormats() {
            fetch('/api/camera_formats')
                .then(response => response.json())
                .then(result => {
                    const resolutionSelect = document.getElementById('resolution');

                    if (result.success && result.data.available) {
                        const options = result.data.resolution_options || [];

                        // Clear existing options
                        resolutionSelect.innerHTML = '';

                        if (options.length > 0) {
                            // Add resolution options grouped by format
                            let currentFormat = '';
                            let optGroup = null;

                            options.forEach(option => {
                                if (option.format !== currentFormat) {
                                    // Create new optgroup for this format
                                    if (optGroup) {
                                        resolutionSelect.appendChild(optGroup);
                                    }
                                    optGroup = document.createElement('optgroup');
                                    optGroup.label = `${option.format} (${option.format_desc})`;
                                    currentFormat = option.format;
                                }

                                const optionElement = document.createElement('option');
                                optionElement.value = option.value;
                                optionElement.textContent = option.label;
                                optGroup.appendChild(optionElement);
                            });

                            // Add the last optgroup
                            if (optGroup) {
                                resolutionSelect.appendChild(optGroup);
                            }

                            resolutionSelect.disabled = false;
                            console.log(`Loaded ${options.length} resolution options`);
                        } else {
                            resolutionSelect.innerHTML = '<option value="">No resolutions available</option>';
                        }
                    } else {
                        resolutionSelect.innerHTML = '<option value="">Formats not available</option>';
                    }
                })
                .catch(error => {
                    console.error('Failed to load camera formats:', error);
                    const resolutionSelect = document.getElementById('resolution');
                    resolutionSelect.innerHTML = '<option value="">Error loading formats</option>';
                });
        }

        // Handle resolution/format change
        function changeResolution() {
            const resolutionSelect = document.getElementById('resolution');
            const selectedValue = resolutionSelect.value;

            if (!selectedValue) {
                return;
            }

            console.log('Changing resolution to:', selectedValue);
            updateStatus('üîÑ Changing camera resolution...', false);

            // Parse the resolution format: "640x480@30fps_MJPG"
            const parts = selectedValue.split('@');
            if (parts.length !== 2) {
                updateStatus('‚ùå Invalid resolution format', true);
                return;
            }

            const resolution = parts[0];  // "640x480"
            const formatPart = parts[1];  // "30fps_MJPG"
            const formatParts = formatPart.split('_');
            const fps = parseFloat(formatParts[0].replace('fps', ''));
            const format = formatParts[1];

            const [width, height] = resolution.split('x').map(Number);

            // Send resolution change request
            apiCall('/api/set_resolution', {
                width: width,
                height: height,
                fps: fps,
                format: format
            })
            .then(response => {
                if (response.success) {
                    updateStatus(`‚úÖ Resolution changed to ${resolution} @ ${fps}fps (${format})`, false);
                } else {
                    updateStatus(`‚ùå ${response.message}`, true);
                }
            })
            .catch(error => {
                updateStatus(`‚ùå Resolution change error: ${error}`, true);
            });
        }

        // Initialize on page load
        window.addEventListener('load', function() {
            // Load available sources first
            loadAvailableSources();

            // Load current camera status
            loadCameraStatus();

            // Load camera controls
            loadCameraControls();

            // Load camera formats after controls
            loadCameraFormats();

            // Set initial status
            setTimeout(() => {
                if (!streamConnected) {
                    handleStreamError();
                }
            }, 3000);
        });

        // API call helper function
        async function apiCall(endpoint, data) {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            });
            return await response.json();
        }

        // Load available video sources
        function loadAvailableSources() {
            fetch('/api/sources')
                .then(response => response.json())
                .then(sources => {
                    const sourceSelect = document.getElementById('videoSource');
                    sourceSelect.innerHTML = '';

                    // Add test pattern first
                    if (sources.test && sources.test.length > 0) {
                        const testGroup = document.createElement('optgroup');
                        testGroup.label = 'üé® Test Pattern';
                        sources.test.forEach(test => {
                            const option = document.createElement('option');
                            option.value = `test|${test.id}`;
                            option.textContent = test.name;
                            testGroup.appendChild(option);
                        });
                        sourceSelect.appendChild(testGroup);
                    }

                    // Add cameras
                    if (sources.cameras && sources.cameras.length > 0) {
                        const cameraGroup = document.createElement('optgroup');
                        cameraGroup.label = 'üì∑ Cameras';
                        sources.cameras.forEach(camera => {
                            const option = document.createElement('option');
                            option.value = `camera|${camera.id}`;
                            option.textContent = camera.name;
                            cameraGroup.appendChild(option);
                        });
                        sourceSelect.appendChild(cameraGroup);
                    }

                    // Add video files
                    if (sources.videos && sources.videos.length > 0) {
                        const videoGroup = document.createElement('optgroup');
                        videoGroup.label = 'üé¨ Sample Videos';
                        sources.videos.forEach(video => {
                            const option = document.createElement('option');
                            option.value = `video|${video.id}`;
                            option.textContent = video.name;
                            videoGroup.appendChild(option);
                        });
                        sourceSelect.appendChild(videoGroup);
                    }

                    if (sourceSelect.options.length === 0) {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'No sources available';
                        sourceSelect.appendChild(option);
                    }

                    // Always enable the video source dropdown after loading sources
                    // This allows users to change sources even if current stream fails
                    sourceSelect.disabled = false;
                })
                .catch(error => {
                    console.error('Failed to load sources:', error);
                    const sourceSelect = document.getElementById('videoSource');
                    sourceSelect.innerHTML = '<option value="">Error loading sources</option>';
                    // Still enable the dropdown so users can retry
                    sourceSelect.disabled = false;
                });
        }

        // Load camera status on page load
        function loadCameraStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(status => {
                    // Update UI with current camera settings
                    document.getElementById('zoom').value = status.zoom;
                    document.getElementById('zoomValue').textContent = status.zoom + 'x';
                    document.getElementById('panX').value = status.pan_x;
                    document.getElementById('panXValue').textContent = status.pan_x;
                    document.getElementById('panY').value = status.pan_y;
                    document.getElementById('panYValue').textContent = status.pan_y;
                    document.getElementById('rotation').value = status.rotation;
                    document.getElementById('targetDetection').value = status.detection_enabled ? 'true' : 'false';
                    document.getElementById('perspectiveCorrection').value = status.perspective_correction_enabled ? 'true' : 'false';
                    document.getElementById('debugMode').value = status.debug_mode ? 'true' : 'false';
                    document.getElementById('debugType').value = status.debug_type || 'combined';
                    document.getElementById('calibrationMode').value = status.calibration_mode ? 'true' : 'false';

                    const resSelect = document.getElementById('resolution');
                    const currentRes = `${status.resolution[0]}x${status.resolution[1]}`;
                    if ([...resSelect.options].some(opt => opt.value === currentRes)) {
                        resSelect.value = currentRes;
                    }

                    // Set current video source
                    const sourceSelect = document.getElementById('videoSource');
                    let currentSourceValue = '';
                    if (status.source_type === 'camera') {
                        currentSourceValue = `camera|camera_${status.current_source}`;
                    } else if (status.source_type === 'video') {
                        const filename = status.current_source.split('/').pop();
                        currentSourceValue = `video|video_${filename}`;
                    } else if (status.source_type === 'test') {
                        currentSourceValue = 'test|test_pattern';
                    }

                    // Find and select the current source
                    for (let i = 0; i < sourceSelect.options.length; i++) {
                        if (sourceSelect.options[i].value === currentSourceValue) {
                            sourceSelect.selectedIndex = i;
                            break;
                        }
                    }

                    // Update controls based on video mode
                    updateControlsForVideoMode(
                        status.is_video_mode,
                        status.native_video_resolution,
                        status.native_video_fps
                    );

                    // Update stream info display
                    updateStreamInfo(status);

                    // Update playback controls
                    updatePlaybackUI(status);
                })
                .catch(error => console.error('Failed to load status:', error));
        }

        // Auto-refresh stream every 30 seconds to prevent timeout
        setInterval(() => {
            if (streamConnected) {
                console.log('Auto-refreshing stream...');
                const img = document.getElementById('videoStream');
                img.src = img.src.split('?')[0] + '?t=' + new Date().getTime();
            }
        }, 30000);

        // Update playback controls every 2 seconds when video is active
        setInterval(() => {
            if (streamConnected) {
                fetch('/api/status')
                    .then(response => response.json())
                    .then(status => {
                        if (status.supports_playback_controls) {
                            updatePlaybackUI(status);
                        }
                    })
                    .catch(error => console.error('Failed to update playback status:', error));
            }
        }, 2000);
    </script>
</body>
</html>